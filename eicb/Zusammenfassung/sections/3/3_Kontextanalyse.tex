\documentclass[
../../eicb_summary.tex,
]
{subfiles}

\externaldocument[ext:]{../../css_summary}
\graphicspath{{../../pics/}}

\begin{document}

\section{Kontextuelle Analyse}

\subsection{Einordnung und Ziele}

\begin{defbox}[Kontextuelle Analyse]
  Die Phase zwischen Syntaxanalyse (AST-Erstellung) und Code-Generierung. Sie prüft Regeln, die nicht durch die kontextfreie Grammatik abgedeckt sind.
  \begin{itemize}
    \item \textbf{Eingabe:} Abstrakter Syntaxbaum (AST).
    \item \textbf{Ausgabe:} \defc{Dekorierter AST} (mit Typ- und Bindungsinformationen).
  \end{itemize}
\end{defbox}

\textbf{Hauptaufgaben:}
\begin{enumerate}
  \item \defc{Identifikation} (Identification): Zuordnung von Bezeichner-Verwendungen zu ihren Deklarationen (Scope-Regeln).
  \item \defc{Typprüfung} (Type Checking): Sicherstellen der Typkompatibilität von Operatoren und Operanden.
\end{enumerate}

\subsection{Identifikation und Geltungsbereiche (Scopes)}

\subsubsection{Blockstrukturen}
\begin{itemize}
  \item \textbf{Monolithisch} (z.\,B. BASIC): Ein globaler Scope. Bezeichner müssen programmweit eindeutig sein.
  \item \textbf{Flach} (z.\,B. FORTRAN): Zwei Ebenen (Global und Lokal).
  \item \textbf{Verschachtelt} (z.\,B. Pascal, Triangle, Java): Beliebige Schachtelungstiefe.
\end{itemize}

\begin{defbox}[Regeln für verschachtelte Scopes]
  \begin{itemize}
    \item \textbf{Deklaration:} Ein Bezeichner darf im selben Block nur einmal deklariert werden.
    \item \textbf{Sichtbarkeit:} Ein Bezeichner ist sichtbar, wenn er im aktuellen oder einem umschließenden Block deklariert wurde.
    \item \defc{Verschattung} (Hiding): Eine lokale Deklaration verdeckt eine gleichnamige Deklaration in einem äußeren Block.
  \end{itemize}
\end{defbox}

\subsubsection{Symboltabelle (Identification Table)}
Datenstruktur zur effizienten Zuordnung von Namen zu Attributen.

\textbf{Implementierung (Triangle-Ansatz):}
Um lineare Suche zu vermeiden, wird eine Kombination aus Hash-Map und Stacks verwendet:
\begin{enumerate}
  \item \texttt{Map<String, Stack<Attribute>>}: Der Bezeichner ist der Key. Der Value ist ein Stack aller aktuellen Deklarationen dieses Namens (oberstes Element = aktuell sichtbare Bindung).
  \item \texttt{Stack<List<String>> scopes}: Verwaltet die Scope-Ebenen. Beim Öffnen eines Scopes (\texttt{openScope}) wird eine neue Liste aufgelegt. Alle darin deklarierten Variablen werden vermerkt, um sie beim Schließen (\texttt{closeScope}) effizient aus der Map zu entfernen.
\end{enumerate}

\subsection{Attribute und AST-Dekoration}

\begin{defbox}[Attribute]
  Gespeicherte Eigenschaften eines Bezeichners:
  \begin{itemize}
    \item \defc{Art}: Variable, Konstante, Typ, Prozedur, Funktion.
    \item \defc{Typ}: Verweis auf die Typstruktur.
    \item Laufzeitinfos: Adressen, Offsets (für Code-Gen).
  \end{itemize}
\end{defbox}

\textbf{Speicherstrategie:}
Statt komplexe Attribut-Klassen zu bauen, nutzt man den AST selbst. Die Symboltabelle speichert \textbf{Referenzen auf die Deklarations-Knoten} im AST.

\textbf{Ablauf der Dekoration:}
\begin{itemize}
  \item Bei der Deklaration (\texttt{Binding Occurrence}): Eintrag in Symboltabelle.
  \item Bei der Verwendung (\texttt{Applied Occurrence}): Suche in Symboltabelle $\rightarrow$ AST-Knoten der Verwendung erhält Zeiger auf AST-Knoten der Deklaration.
\end{itemize}

\subsection{Typprüfung (Type Checking)}

\begin{defbox}[Statische vs. Dynamische Typisierung]
  \begin{itemize}
    \item \defc{Statisch} (Triangle, Java): Prüfung zur Compile-Zeit. Jeder Ausdruck hat einen fixen Typ. Sicherer und performanter.
    \item \defc{Dynamisch} (Python, Lisp): Prüfung zur Laufzeit. Flexibler, aber fehleranfälliger.
  \end{itemize}
\end{defbox}

\textbf{Algorithmus (Bottom-Up):}
Die Prüfung erfolgt rekursiv von den Blättern zur Wurzel:
\begin{enumerate}
  \item \textbf{Blätter:} Typen von Literalen (z.\,B. \texttt{1} $\to$ Integer) sind bekannt. Variablen-Typen kommen aus der Identifikation (Symboltabelle).
  \item \textbf{Knoten:} Typ eines Ausdrucks $E_1 \ op \ E_2$ wird aus den Typen der Kinder $E_1, E_2$ und der Signatur von $op$ abgeleitet.
  \item \textbf{Kontext-Check:} Z.\,B. muss die Bedingung in \texttt{if E ...} vom Typ \texttt{Boolean} sein.
\end{enumerate}

\subsection{Implementierung mit dem Visitor-Pattern}

Um die Logik (Typprüfung) von der Datenstruktur (AST) zu trennen, wird das \defc{Visitor-Pattern} verwendet. Dies verhindert das Aufblähen der AST-Klassen.

\begin{defbox}[Funktionsweise Visitor]
  \begin{itemize}
    \item \textbf{Double Dispatch:} Der AST-Knoten ruft \texttt{v.visit(this)} auf, der Visitor führt dann die spezifische Methode (z.\,B. \texttt{visitAssignCommand}) aus.
    \item \textbf{Generics:} \texttt{Visitor<RetTy, ArgTy>} ermöglicht flexible Rückgabe- und Argumenttypen.
  \end{itemize}
\end{defbox}

\textbf{Spezialisierte Checker (Best Practice):}
Statt eines riesigen Visitors gibt es spezialisierte Unterklassen von \texttt{VisitorBase}:
\begin{itemize}
  \item \texttt{ExpressionChecker}: Liefert \texttt{TypeDenoter} zurück (da Ausdrücke einen Typ haben).
  \item \texttt{CommandChecker}: Liefert \texttt{Void} zurück (da Befehle keinen Typ haben).
\end{itemize}

\textbf{Beispiele für Visitor-Methoden:}
\begin{itemize}
  \item \texttt{visitAssignCommand}: Prüft, ob LHS eine Variable ist und ob $Type(LHS) == Type(RHS)$.
  \item \texttt{visitLetCommand}: Ruft \texttt{idTable.openScope()} auf, besucht Deklarationen, besucht Body, ruft \texttt{idTable.closeScope()} auf.
\end{itemize}

\subsection{Standardumgebung (Standard Environment)}

Vordefinierte Bezeichner (z.\,B. \texttt{Integer}, \texttt{true}, \texttt{put}) sind nicht Teil der Grammatik, sondern werden \textbf{vor} der Analyse in die Symboltabelle geladen.

\textbf{Realisierung:}
Es werden künstliche AST-Fragmente erstellt (z.\,B. eine \texttt{ConstDeclaration} für \texttt{true}), die dann in den globalsten Scope eingefügt werden.

\subsection{Typäquivalenz}

Wann sind zwei Typen $T_1$ und $T_2$ gleich?

\begin{defbox}[Äquivalenzarten]
  \begin{itemize}
    \item \defc{Strukturelle Äquivalenz} (Triangle): Typen sind gleich, wenn ihre Struktur identisch ist (z.\,B. Array gleicher Länge und gleicher Elementtyp).
    \item \defc{Namensäquivalenz} (Pascal, Ada): Typen sind nur gleich, wenn sie denselben Typnamen haben. Jede \texttt{type}-Definition erzeugt einen neuen, inkompatiblen Typ.
  \end{itemize}
\end{defbox}

\textbf{Beispiel Triangle (Strukturell):}
\begin{itemize}
  \item \texttt{array 8 of Char} $==$ \texttt{array 8 of Char} (Äquivalent)
  \item \texttt{record a:Int end} $\neq$ \texttt{record b:Int end} (Nicht äquivalent, da Bezeichner zur Struktur gehören).
\end{itemize}

\subsection{Zusammenfassung des Gesamtablaufs}
\begin{enumerate}
  \item Aufbau der \textbf{Standardumgebung}.
  \item \textbf{Tiefensuche} über den AST (Visitor).
  \item Bei Eintritt in Block (\texttt{Let}): \texttt{openScope}.
  \item Bei Deklaration: Eintrag in Symboltabelle + Prüfung auf Dopplung.
  \item Bei Verwendung: Lookup in Symboltabelle + \textbf{Identifikation} (Setzen des Links).
  \item Berechnung der Typen von unten nach oben (\textbf{Typprüfung}).
  \item Bei Austritt aus Block: \texttt{closeScope}.
\end{enumerate}

\end{document}
