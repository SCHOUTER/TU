% !TEX root = ./eicb_summary.tex

\section{Kontextanalyse}

\begin{defbox}[Ziel der Kontextanalyse]
Überprüfung der \defc{kontextuellen Einschränkungen}:
\begin{itemize}
  \item Geltungsbereiche von Bezeichnern
  \item Typregeln (Typüberprüfung)
  \item Konsistenzregeln (z.\,B. Funktionsaufrufe, Parameteranzahl, etc.)
\end{itemize}
\end{defbox}

\subsection{Geltungsbereiche und Symboltabellen}

\subsubsection{Grundlagen}
\begin{itemize}
  \item Jede Deklaration \textbf{bindet} einen Namen.
  \item Jede Verwendung eines Bezeichners muss einer gültigen \textbf{Bindung} zugeordnet sein.
  \item Fehlende Bindung $\Rightarrow$ \defc{Fehler}.
\end{itemize}

\begin{defbox}[Symboltabelle]
Datenstruktur zur \defc{Zuordnung von Namen zu Attributen}.
\begin{itemize}
  \item Schnelles Nachschlagen (z.\,B. Hash-Tabelle)
  \item Enthält Art, Typ, Sichtbarkeit, evtl. Adresse
  \item Hierarchische Struktur für verschachtelte Blöcke
\end{itemize}
\end{defbox}

\subsubsection{Blockstrukturen}
\begin{itemize}
  \item \textbf{Monolithisch:} Alle Deklarationen global (BASIC, COBOL)
  \item \textbf{Flach:} Global + lokal (FORTRAN)
  \item \textbf{Verschachtelt:} Beliebige Tiefe (Pascal, Ada, Java)
\end{itemize}

\begin{defbox}[Geltungsbereichsregeln]
\begin{itemize}
  \item Kein Bezeichner mehrfach innerhalb eines Blocks.
  \item Verwendung nur mit Deklaration im lokalen oder umschließenden Block.
  \item Lokale Deklarationen überdecken äußere.
\end{itemize}
\end{defbox}

\subsection{Attribute}

\begin{defbox}[Attribute]
Informationen, die zu einem Bezeichner gespeichert werden:
\begin{itemize}
  \item Art (Konstante, Variable, Funktion)
  \item Typ (int, char, boolean, array, record, …)
  \item Sichtbarkeit, ggf. Speicheradresse
\end{itemize}
\end{defbox}

\textbf{Verwendung:}
\begin{itemize}
  \item Überprüfung von Geltungsbereichs- und Typregeln
  \item Vorbereitung auf Code-Generierung
\end{itemize}

\textbf{Speicherung:}
\begin{itemize}
  \item Einfach: explizite Speicherung in Klassen
  \item Besser: Referenz auf \defc{AST-Knoten} der Deklaration
\end{itemize}

\subsection{Identifikation}

\begin{defbox}[Identifikation]
Erste Phase der Kontextanalyse. Ordnet jede \defc{Verwendung} einer \defc{Definition} zu.
\end{defbox}

\textbf{Ziel:} Aufbau einer Symboltabelle durch AST-Durchlauf.

\textbf{Kombination mit:} Typprüfung (zweite Phase).

\subsection{Typprüfung}

\begin{defbox}[Typ]
Einschränkung der möglichen Interpretationen eines Speicherbereiches oder Ausdrucks.
\end{defbox}

\begin{itemize}
  \item \textbf{Statische Typisierung:} zur Compile-Zeit (z.\,B. Pascal, C)
  \item \textbf{Dynamische Typisierung:} zur Laufzeit (z.\,B. Python)
\end{itemize}

\subsubsection{Typüberprüfung – Prinzip}
\begin{enumerate}
  \item Bestimme Typen von Teilausdrücken (\textit{Bottom-Up} im AST)
  \item Prüfe, ob Typanforderungen des Kontextes erfüllt sind
\end{enumerate}

\textbf{Typregeln:}
\begin{itemize}
  \item \texttt{if E then …} → $E$ muss vom Typ \texttt{Boolean} sein.
  \item Zuweisung $x := E$ → Typ von $x$ = Typ von $E$.
  \item Binäre Operatoren: $E_1$ \texttt{op} $E_2$ typkorrekt, wenn $E_1:T_1$, $E_2:T_2$ und $op:T_1\times T_2\rightarrow R$.
\end{itemize}

\subsection{Implementierung der Kontextanalyse}

\begin{defbox}[AST-Dekoration]
\defc{Dekorierter AST} speichert zusätzliche Informationen:
\begin{itemize}
  \item Typ jedes Ausdrucks
  \item Verweis auf bindende Deklaration
\end{itemize}
\end{defbox}

\textbf{Vorgehensweisen:}
\begin{itemize}
  \item OO-Ansatz: Jede AST-Klasse implementiert \texttt{check()}.
  \item Funktionaler Ansatz: Separate Typprüfungsfunktion.
  \item \textbf{Visitor-Pattern:} Modularer Ansatz zur Trennung von Struktur und Verhalten.
\end{itemize}

\begin{defbox}[Visitor-Pattern]
Ermöglicht neue Operationen auf AST-Knoten, ohne deren Klassen zu verändern.
\end{defbox}

\textbf{Beispiele:}
\begin{itemize}
  \item \texttt{visitAssignCommand}: prüft Typkompatibilität von LHS und RHS.
  \item \texttt{visitLetCommand}: öffnet/schließt Scope in Symboltabelle.
  \item \texttt{visitIfCommand}: prüft Boolean-Bedingung.
\end{itemize}

\subsection{Standardumgebung}

\begin{defbox}[Standardumgebung]
Vordefinierte Typen, Konstanten und Operationen, die zur Analyse vorhanden sein müssen.
\end{defbox}

\textbf{Beispiele:}
\begin{itemize}
  \item Typen: \texttt{Integer}, \texttt{Boolean}, \texttt{Char}
  \item Konstanten: \texttt{true}, \texttt{false}
  \item Operatoren: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{<}, \texttt{=}
\end{itemize}

Implementierung:
\begin{itemize}
  \item Als AST-Einträge vor der Analyse eingefügt.
  \item Liegen auf äußerster Scope-Ebene (Ebene 0/1).
\end{itemize}

\subsection{Typäquivalenz}

\begin{defbox}[Typäquivalenz]
Regel, wann zwei Typen als "gleich" gelten.
\end{defbox}

\subsubsection{Ansätze}
\begin{itemize}
  \item \textbf{Strukturelle Äquivalenz:} gleiche Struktur $\Rightarrow$ äquivalent.
  \item \textbf{Namenäquivalenz:} nur identische Typdefinitionen sind äquivalent.
\end{itemize}

\textbf{In Triangle:} strukturelle Typäquivalenz.

\textbf{Beispiele:}
\begin{itemize}
  \item \texttt{record n: Integer; c: Char end} $\neq$ \texttt{record c: Char; n: Integer end}
  \item \texttt{array 8 of Char} = \texttt{array 8 of Char}
\end{itemize}

\subsubsection{Komplexe Typen}
\begin{itemize}
  \item Verweis auf Typbeschreibung im AST (\texttt{TypeDenoter})
  \item Struktureller Vergleich von Sub-ASTs zur Typprüfung
\end{itemize}

\subsection{Algorithmus der Kontextanalyse}

\begin{defbox}[Algorithmus]
Ein kombinierter AST-Durchlauf:
\begin{enumerate}
  \item Tiefensuche (DFS) über AST
  \item Identifikation (Symboltabelle aufbauen)
  \item Typprüfung (Dekoration des ASTs)
\end{enumerate}
\end{defbox}

\textbf{Voraussetzung:} Bindungen erscheinen im Code \textbf{vor} Verwendungen.

\textbf{Ergebnis:} Dekorierter AST mit allen Typ- und Scopeinformationen.

\subsection{Zusammenfassung}
\begin{itemize}
  \item Kontextanalyse = Identifikation + Typprüfung
  \item Symboltabelle verwaltet Geltungsbereiche
  \item Typprüfung sichert korrekte Operationen
  \item Visitor-Pattern modularisiert Implementierung
  \item Standardumgebung liefert primitive Typen
  \item Triangle nutzt strukturelle Typäquivalenz
\end{itemize}

\begin{defbox}[Prüfungsrelevante Kernbegriffe]
Symboltabelle, Geltungsbereich, Attribut, Typüberprüfung, AST-Dekoration, Visitor, Standardumgebung, Typäquivalenz
\end{defbox}
