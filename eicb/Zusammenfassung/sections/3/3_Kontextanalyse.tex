\documentclass[
../../eicb_summary.tex,
]
{subfiles}

\externaldocument[ext:]{../../eicb_summary}



\begin{document}

\section{Kontextuelle Analyse}

Die kontextuelle Analyse ist die Phase im Compilerbau, die zwischen der Syntaxanalyse (Parsing) und der Code-Generierung steht. Sie dient dazu, die Gültigkeit des Programms über die reine Syntax hinaus zu überprüfen und den abstrakten Syntaxbaum (AST) mit semantischen Informationen zu angereichern.

\begin{center}
   \includegraphics[width=0.7\textwidth]{eicb_1_03-contextanalysis-handout_page_3_1.png}
\end{center}

\begin{defbox}[Ziel der kontextuellen Analyse]
   Eingabe: Ein Abstrakter Syntaxbaum (AST).\\
   Ausgabe: Ein \defc{dekorierter AST} (angereichert mit Typinformationen und Bindungen) oder Fehlermeldungen.\\
   Aufgaben: Überprüfung der \defc{Geltungsbereiche} (Identification) und der \defc{Typregeln} (Type Checking).
\end{defbox}

\subsection{Kontextuelle Einschränkungen}

Die Syntaxanalyse prüft lediglich die grammatikalische Struktur. Die kontextuelle Analyse prüft Bedingungen, die vom Kontext abhängen:

\begin{itemize}
   \item \textbf{Geltungsbereiche (Scope):} Jeder verwendete Bezeichner (Variable, Funktion) muss korrekt deklariert (gebunden) sein.
   \item \textbf{Typen:} Operationen müssen auf kompatiblen Datentypen ausgeführt werden (z.\,B. \texttt{if}-Bedingung muss \texttt{Boolean} sein).
\end{itemize}

\subsubsection{Geltungsbereiche (Identification)}
Es wird zwischen der \textit{Deklaration} (Bindung) und der \textit{Benutzung} (Verwendung) eines Namens unterschieden.

\begin{defbox}[Regel für Bezeichner]
   Falls im Geltungsbereich der Verwendung eines Bezeichners $n$ keine Bindung von $n$ existiert $\rightarrow$ Fehler.
\end{defbox}

\subsubsection{Typprüfung}
Wir betrachten hier die \defc{statische Typisierung}, bei der Typen zur Compile-Zeit geprüft werden.
\begin{itemize}
   \item Jeder Wert hat einen Typ.
   \item Jede Operation hat Anforderungen an die Typen ihrer Operanden und liefert einen Ergebnistyp.
   \item \textbf{Vorteile:} Fehlervermeidung (\glqq eckiger Kreis\grqq) und Laufzeitoptimierung (keine Typchecks zur Laufzeit nötig).
\end{itemize}

\subsection{Symboltabellen (Identification Tables)}

Um Namen (Strings) effizient ihren Attributen (Typ, Art, Adresse) zuzuordnen, wird eine Symboltabelle verwendet. Dies vermeidet langsames Suchen im AST.

\subsubsection{Struktur von Geltungsbereichen}

\begin{enumerate}
   \item \textbf{Monolithische Blockstruktur:}
         \begin{itemize}
            \item Nur ein globaler Geltungsbereich (z.\,B. BASIC).
            \item Jeder Bezeichner darf nur einmal deklariert werden.
         \end{itemize}
   \item \textbf{Flache Blockstruktur:}
         \begin{itemize}
            \item Globale und lokale Ebene (z.\,B. FORTRAN).
            \item Lokale Deklarationen verschatten globale, werden aber nach Blockende verworfen.
         \end{itemize}
   \item \textbf{Verschachtelte Blockstruktur (Nested Scopes):}
         \begin{itemize}
            \item Beliebige Schachtelungstiefe (z.\,B. Pascal, Java, Ada).
            \item \textbf{Regel:} Kein Bezeichner darf im \textit{selben} Block mehrfach deklariert werden. Verwendete Bezeichner müssen im lokalen oder einem umschließenden Block deklariert sein.
         \end{itemize}
\end{enumerate}

% [Grafik: Darstellung verschachtelter Geltungsbereiche als Baumstruktur. Suchpfad geht von lokal nach global.]

\subsubsection{Implementierung der Symboltabelle}

Eine effiziente Implementierung für verschachtelte Blöcke verwendet eine Hash-Tabelle, die Stacks enthält.

\begin{itemize}
   \item \textbf{Datenstruktur:} \texttt{Map<String, Stack<Attribute>{}> idents}
   \item Der Schlüssel ist der Bezeichnername.
   \item Der Wert ist ein Stack von Attributen. Oben auf dem Stack liegt immer die Deklaration der tiefsten (aktuellsten) Verschachtelungsebene.
   \item Zusätzlich gibt es einen \texttt{Stack<List<String>{}> scopes}, der speichert, welche Bezeichner zu welchem Scope gehören, um sie beim Verlassen des Scopes (\texttt{closeScope}) wieder aus der Map zu entfernen.
\end{itemize}

\begin{defbox}[Operationen der Symboltabelle]
   \begin{itemize}
      \item \texttt{enter(id, attr)}: Fügt eine neue Bindung hinzu.
      \item \texttt{retrieve(id)}: Liefert das Attribut der innersten sichtbaren Deklaration (oberstes Element im Stack).
      \item \texttt{openScope()}: Öffnet einen neuen Geltungsbereich.
      \item \texttt{closeScope()}: Entfernt alle Einträge des aktuellen Geltungsbereichs.
   \end{itemize}
\end{defbox}

\subsection{Attribute und AST-Dekoration}

Anstatt alle Informationen (Art, Typ, etc.) explizit in komplexen Attribut-Objekten zu speichern, nutzt man im Compilerbau oft den AST selbst.

\begin{itemize}
   \item \textbf{Idee:} Im AST stehen bei der Deklaration bereits alle Informationen.
   \item \textbf{Umsetzung:} Die Symboltabelle speichert Verweise (Zeiger) auf die Deklarations-Knoten im AST.
   \item \textbf{Dekoration:} Verwendungsstellen im AST (z.\,B. \texttt{VnameExpr}) erhalten einen Zeiger auf ihre Deklarationsstelle. Ausdrucksknoten (\texttt{Expression}) erhalten ein Feld für ihren berechneten Typ.
\end{itemize}

\begin{center}
   \includegraphics[width=0.7\textwidth]{eicb_1_03-contextanalysis-handout_page_29_1.png}
\end{center}

\subsection{Implementierung: Das Visitor Pattern}

Für die Durchquerung des AST zur Typprüfung und Code-Generierung eignet sich das \defc{Visitor Pattern}. Es trennt die Datenstruktur (AST) von den Operationen (Check, Encode).

\subsubsection{Standard Visitor}
Das Interface definiert für jeden Knotentyp eine Methode:
\begin{verbatim}
public interface Visitor<RetTy, ArgTy> {
    RetTy visitProgram(Program p, ArgTy arg);
    RetTy visitAssignCommand(AssignCommand c, ArgTy arg);
    // ... für alle AST-Knoten
}
\end{verbatim}
Jede AST-Klasse implementiert eine \texttt{visit}-Methode, die den Visitor aufruft (Double Dispatch).

\subsubsection{Herausforderung und Lösung in Triangle}
Da verschiedene AST-Knoten unterschiedliche Rückgabetypen bei der Analyse benötigen (z.\,B. liefert ein \texttt{Command} nichts zurück, eine \texttt{Expression} aber einen Typ), ist ein einziger generischer Visitor oft unhandlich.

\textbf{Lösung:} Spezialisierte Visitors (Checkers), die von einer Basisklasse (\texttt{VisitorBase}) erben.
\begin{itemize}
   \item \texttt{CommandChecker}: Überprüft Anweisungen (Return: \texttt{Void}).
   \item \texttt{ExpressionChecker}: Überprüft Ausdrücke (Return: \texttt{TypeDenoter}).
   \item \texttt{DeclarationChecker}: Trägt Deklarationen in die Symboltabelle ein.
\end{itemize}

\subsection{Algorithmus der Kontextanalyse}

Die Analyse erfolgt meist als \defc{Tiefensuche} (Depth-First Traversal) von links nach rechts durch den AST. Identifikation und Typprüfung werden oft in einem Pass kombiniert (möglich in Sprachen wie Triangle, wo \glqq Definition vor Verwendung\grqq{} gilt).

\subsubsection{Vorgehen für spezifische Knoten}

\textbf{1. Variablendeklaration (\texttt{VarDecl}):}
\begin{enumerate}
   \item Prüfe den Typ-Teilbaum (validiere Typnamen).
   \item Prüfe, ob der Bezeichner im aktuellen Scope bereits existiert (Duplikat-Check).
   \item Trage Bezeichner und Verweis auf \texttt{VarDecl}-Knoten in Symboltabelle ein.
\end{enumerate}

\textbf{2. Zuweisung (\texttt{AssignCmd} $V := E$):}
\begin{enumerate}
   \item Besuche $V$ (Variable): Ermittle Typ $T_V$ und prüfe, ob es eine Variable (keine Konstante) ist.
   \item Besuche $E$ (Expression): Ermittle Typ $T_E$.
   \item Prüfe: $T_V \equiv T_E$ (Typkompatibilität).
\end{enumerate}

\textbf{3. Bedingung (\texttt{IfCmd} if $E$ then $C_1$ else $C_2$):}
\begin{enumerate}
   \item Besuche $E$: Typ muss \texttt{Boolean} sein.
   \item Besuche $C_1$ und $C_2$ rekursiv.
\end{enumerate}

\textbf{4. Binärer Ausdruck (\texttt{BinaryExpr} $E_1 \ op \ E_2$):}
\begin{enumerate}
   \item Bestimme Typen $T_1$ von $E_1$ und $T_2$ von $E_2$.
   \item Suche Operator $op$ in Symboltabelle.
   \item Prüfe, ob $op$ für ($T_1, T_2$) definiert ist.
   \item Ergebnis ist der Ergebnistyp des Operators.
\end{enumerate}

\subsubsection{Let-Command (Scope Management)}
Beim Knoten \texttt{LetCommand} (lokale Deklarationen) muss das Scope-Management erfolgen:
\begin{verbatim}
visitLetCommand(ast) {
  idTable.openScope();
  visit(ast.Declarations); // Trägt lokale Variablen ein
  visit(ast.Command);      // Rumpf mit Sichtbarkeit
  idTable.closeScope();    // Entfernt lokale Variablen
}
\end{verbatim}

\subsection{Standardumgebung}

Die Standardumgebung (Standard Environment) enthält vordefinierte Typen (\texttt{Integer}, \texttt{Boolean}) und Funktionen (\texttt{put}, \texttt{get}).

\begin{itemize}
   \item Diese werden nicht geparst, sondern müssen vor der Analyse in die Symboltabelle geladen werden.
   \item \textbf{Implementierung:} Man erzeugt manuell kleine AST-Teilbäume für diese Definitionen (z.\,B. eine \texttt{ConstDeclaration} für \texttt{true}) und trägt sie in den initialen Scope ein.
   \item \texttt{Integer}, \texttt{Boolean}, etc. werden oft als Singleton-Objekte implementiert (z.\,B. \texttt{Type.intT}).
\end{itemize}

\subsection{Typäquivalenz}

Wann gelten zwei Typen als \glqq gleich\grqq? Dies ist besonders bei Arrays und Records wichtig.

\begin{itemize}
   \item \textbf{Strukturelle Typäquivalenz (Triangle):}
         Zwei Typen sind äquivalent, wenn ihre Struktur identisch ist.
         \begin{itemize}
            \item Beispiel: \texttt{array 8 of Char} ist äquivalent zu \texttt{array 8 of Char}, auch wenn sie an verschiedenen Stellen stehen.
         \end{itemize}

   \item \textbf{Namensäquivalenz (Name Equivalence):}
         Jede Typdefinition erzeugt einen einzigartigen Typ.
         \begin{itemize}
            \item Beispiel:
                  \begin{verbatim}
type T1 = array 8 of Char;
type T2 = array 8 of Char;
var a : T1;
var b : T2;
        \end{verbatim}
                  Bei Namensäquivalenz sind \texttt{a} und \texttt{b} \textbf{nicht} kompatibel.
                  Bei struktureller Äquivalenz sind sie kompatibel.
         \end{itemize}
\end{itemize}

\textbf{Handhabung komplexer Typen:}
In der Analyse werden Typnamen (z.\,B. \glqq Word\grqq) durch Verweise auf ihre tatsächliche Definition (den Sub-AST, z.\,B. \texttt{ArrayTypeDenoter}) aufgelöst. Der Vergleich erfolgt dann rekursiv über die Struktur der \texttt{TypeDenoter}.


\end{document}