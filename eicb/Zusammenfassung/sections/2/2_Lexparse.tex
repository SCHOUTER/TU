\documentclass[
../../eicb_summary.tex,
]
{subfiles}

\externaldocument[ext:]{../../eicb_summary}

\begin{document}

\section{Syntaktische Analyse/Lexparse}

\begin{defbox}[Übersetzung und Phasen]
  \begin{itemize}
    \item \defc{Syntaxanalyse} → Struktur des Programms (AST)
    \item \defc{Kontextanalyse} → Bedeutungsprüfung (Typen, Gültigkeit)
    \item \defc{Codegenerierung} → Übersetzung in Zielcode
  \end{itemize}
\end{defbox}

\subsection{Compilerstruktur}
\textbf{Ein-Pass-Compiler:}
\begin{itemize}
  \item Führt alle Phasen gleichzeitig aus
  \item Keine echte Zwischendarstellung (IR)
  \item Typisch für kleine Sprachen (z. B. Pascal)
\end{itemize}

\textbf{Multi-Pass-Compiler:}
\begin{itemize}
  \item Arbeitet mit mehreren Durchgängen über Quelltext/IR
  \item Datenweitergabe über IR (AST)
  \item Bessere Modularität und Optimierung
\end{itemize}

\subsection{Syntaxanalyse – Überblick}
\begin{itemize}
  \item \textbf{Scanner (Lexer)}: Wandelt Zeichenfolge → Tokenfolge
  \item \textbf{Parser}: Wandelt Tokenfolge → Abstract Syntax Tree (AST)
  \item Token = atomares Symbol des Quellprogramms
\end{itemize}

\begin{defbox}[Kontextfreie Grammatik (CFG)]
  Eine CFG ist ein 4-Tupel $(N, T, P, S)$ mit:
  \begin{itemize}
    \item $N$: Nichtterminale
    \item $T$: Terminale
    \item $P$: Produktionen
    \item $S$: Startsymbol
  \end{itemize}
\end{defbox}

\subsection{BNF und EBNF}
\begin{itemize}
  \item \textbf{BNF:} Grundform zur Definition von Grammatiken
  \item \textbf{EBNF:} Erweiterung mit regulären Ausdrücken, optionalen und wiederholten Konstrukten
  \item Beispiel:
        \[
          \text{Expression} ::= \text{primary-Expression (operator primary-Expression)*}
        \]
\end{itemize}

\subsection{Grammatiktransformationen}
\begin{itemize}
  \item \defc{Gruppierung}: Zusammenfassen gleicher LHS
  \item \defc{Linksausklammern}: Gemeinsame Präfixe auslagern
  \item \defc{Linksrekursion beseitigen}: $N ::= X | N Y \Rightarrow N ::= X (Y)^*$
  \item \defc{Ersetzung von Nicht-Terminalen}: falls nur eine Regel existiert
\end{itemize}

\subsection{Parsing-Grundlagen}
\begin{defbox}[Parsing]
  Entscheidung, ob Eingabe zur Grammatik gehört und Aufbau des Syntaxbaumes.
\end{defbox}
\begin{itemize}
  \item \textbf{Top-Down (z. B. rekursiver Abstieg):} Von Startsymbol zu Terminalen
  \item \textbf{Bottom-Up (z. B. Shift/Reduce):} Von Terminalen zur Wurzel
\end{itemize}

\subsection{Top-Down Parsing}
\begin{itemize}
  \item Aufbau des Syntaxbaums von oben nach unten
  \item Expandiere jeweils das linke Nichtterminal
  \item LL(k): Grammatik, bei der mit $k$ Lookahead-Tokens eindeutig entschieden werden kann
  \item \defc{LL(1)} → wichtigster Fall für rekursiven Abstieg
\end{itemize}

\subsection{Rekursiver Abstieg}
\begin{defbox}[Rekursiver Abstieg]
  Jedes Nichtterminal erhält eine Prozedur \texttt{parseN()}, deren Aufrufstruktur dem Parsebaum entspricht.
\end{defbox}
\begin{itemize}
  \item \textbf{accept(t)} prüft aktuelles Token
  \item \textbf{acceptIt()} akzeptiert aktuelles Token ohne Prüfung
  \item \textbf{currentToken}: vom Scanner geliefert
\end{itemize}

\subsection{Starter- und Folgemengen}

% Definition der Mengenarten für den Kontext
\begin{itemize}
  \item $T$: Menge der Terminale (Tokens, z.B. \texttt{id}, \texttt{+})
  \item $N$: Menge der Nichtterminale (Variablen, z.B. \texttt{Expression})
  \item $\varepsilon$: Das leere Wort (Epsilon)
  \item $\$$: End-of-File Marker (eof)
\end{itemize}

% WICHTIG: Die geschweiften Klammern { ... } um den Titel verhindern, 
% dass LaTeX bei den inneren eckigen Klammern [[ ]] abstürzt.

\begin{defbox}[{$\text{starters}[[X]]$ (First-Menge)}]
  Menge aller Terminale, mit denen ein aus $X$ abgeleiteter String beginnen kann.

  \textbf{Berechnung:}
  \begin{itemize}
    \item \textbf{Ist $X \in T$ (Terminal):} \\
          $starters[[X]] = \{X\}$
    \item \textbf{Ist $X \in N$ (Nichtterminal) mit $X \rightarrow Y_1 Y_2 \dots$:}
          \begin{itemize}
            \item Füge $starters[[Y_1]] \setminus \{\varepsilon\}$ hinzu.
            \item Falls $\varepsilon \in starters[[Y_1]]$, füge auch $starters[[Y_2]]$ hinzu (usw.).
          \end{itemize}
    \item \textbf{Epsilon:} Falls $X \rightarrow \varepsilon$ existiert, ist $\varepsilon \in starters[[X]]$.
  \end{itemize}
\end{defbox}

\begin{defbox}[{$\text{follow}[[A]]$ (Folgemenge)}]
  Menge aller Terminale, die in einer Satzform unmittelbar rechts von einem Nichtterminal $A$ stehen können.

  \textbf{Regeln:}
  \begin{enumerate}
    \item \textbf{Startsymbol $S$:} Enthält immer das Ende-Zeichen ($\$$).
    \item \textbf{Rechter Nachbar ($B \rightarrow \alpha A \beta$):} \\
          Alles aus $starters[[\beta]]$ (außer $\varepsilon$) kommt zu $follow[[A]]$.
    \item \textbf{Eltern-Vererbung ($B \rightarrow \alpha A$ oder $\beta \Rightarrow^* \varepsilon$):} \\
          Wenn $A$ am Ende steht (oder $\beta$ wegfallen kann), erbt $A$ alles aus $follow[[B]]$.
  \end{enumerate}
  \textit{Hinweis: Folgemengen enthalten niemals $\varepsilon$, können aber $\$$ enthalten.}
\end{defbox}

\subsubsection*{LL(1)-Konfliktfreiheit}
Eine Grammatik ist LL(1), wenn für jede Produktion mit Alternativen $A \rightarrow \alpha \mid \beta$ gilt:

\begin{itemize}
  \item \textbf{Disjunkte Starter (Auswahl-Konflikt):} \\
        Die Alternativen dürfen nicht mit demselben Terminal beginnen. \\
        $starters[[\alpha]] \cap starters[[\beta]] = \emptyset$

  \item \textbf{Disjunkte Folge bei Epsilon (Nullable-Konflikt):} \\
        Falls $\alpha \Rightarrow^* \varepsilon$ (d.h. $\alpha$ kann verschwinden), darf die Folgemenge von $A$ keinen gemeinsamen Start mit $\beta$ haben. \\
        $starters[[\beta]] \cap follow[[A]] = \emptyset$
\end{itemize}

\subsubsection{Bottom-Up Parsing (Shift \& Reduce)}
Beim Bottom-Up Parsing (z.B. LR-Parser) wird die Eingabe von links gelesen und versucht, sie auf das Startsymbol zu reduzieren.

\textbf{Operationen:}
\begin{itemize}
  \item \textbf{Shift:} Schiebe das nächste Eingabe-Symbol auf den Stack.
  \item \textbf{Reduce:} Ersetze eine Symbolfolge oben auf dem Stack durch das entsprechende Nichtterminal (gemäß Grammatikregel).
\end{itemize}

\textbf{Beispiel-Trace (aus Übung):}
Grammatik: $S \rightarrow Ac$, $A \rightarrow aA \mid b$. Eingabe: $aabc$

\begin{center}
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Stack} & \textbf{Eingabe} & \textbf{Aktion}             \\ \hline
    $\epsilon$     & $aabc$           & Shift $a$                   \\ \hline
    $a$            & $abc$            & Shift $a$                   \\ \hline
    $aa$           & $bc$             & Shift $b$                   \\ \hline
    $aab$          & $c$              & Reduce ($A \rightarrow b$)  \\ \hline
    $aaA$          & $c$              & Reduce ($A \rightarrow aA$) \\ \hline
    $aA$           & $c$              & Reduce ($A \rightarrow aA$) \\ \hline
    $A$            & $c$              & Shift $c$                   \\ \hline
    $Ac$           & $\epsilon$       & Reduce ($S \rightarrow Ac$) \\ \hline
    $S$            & $\epsilon$       & \textbf{Akzeptiert}         \\ \hline
  \end{tabular}
\end{center}

\subsection{AST (Abstract Syntax Tree)}
\begin{itemize}
  \item Strukturierte Repräsentation des Programms
  \item Parser erzeugt AST-Knoten beim rekursiven Abstieg
  \item Jede Grammatikregel entspricht einer AST-Unterklasse
\end{itemize}

\begin{defbox}[AST-Aufbau]
  \begin{itemize}
    \item \textbf{Abstrakte Basisklasse:} \texttt{AST}
    \item \textbf{Subklassen:} \texttt{Command}, \texttt{Expression}, \texttt{Declaration}, \texttt{TypeDenoter}
    \item Terminalknoten (z. B. Identifier, Operator) speichern tatsächlichen Text
  \end{itemize}
\end{defbox}

\subsection{Scanner (Lexikalische Analyse)}
\begin{defbox}[Scanner]
  Wandelt Zeichen → Tokens anhand regulärer Ausdrücke (REs).
\end{defbox}

\textbf{Aufgaben:}
\begin{itemize}
  \item Entfernt Whitespace, Kommentare
  \item Liefert \texttt{Token(kind, spelling, position)}
  \item Nutzt endlichen Automaten oder rekursiven Abstieg
\end{itemize}

\textbf{Beispiel EBNF Mini-Triangle:}
\[
  \begin{aligned}
    \text{Identifier}      & ::= \text{Letter (Letter | Digit)*} \\
    \text{Integer-Literal} & ::= \text{Digit Digit*}             \\
    \text{Operator}        & ::= + | - | * | / | < | > | =       \\
  \end{aligned}
\]

\subsection{Automatisierung}
\begin{itemize}
  \item Scanner-Generatoren: \textbf{JLex}, \textbf{JFlex}
  \item Parser-Generatoren: \textbf{ANTLR (LL*)}, \textbf{JavaCC (LL(k))}
\end{itemize}

\subsection{Typische Fehler}
\begin{itemize}
  \item Linksrekursion nicht entfernt
  \item Linksausklammern vergessen
  \item Anfangs-/Folgemengen überschneiden sich → nicht LL(1)
  \item Schlüsselwörter nicht vom Identifier getrennt
\end{itemize}

\subsection{Zusammenfassung – Wichtigste Punkte}
\begin{itemize}
  \item CFG-Grundlagen (BNF/EBNF)
  \item Transformationen: Gruppierung, Linksausklammern, Rekursionsbeseitigung
  \item LL(1)-Parsing und Bedingungen
  \item Rekursiver Abstieg: Struktur und Methoden
  \item AST-Struktur: Klassenhierarchie, Terminal- und Nichtterminalknoten
  \item Scanner: REs, endliche Automaten, Schlüsselworterkennung
\end{itemize}

\end{document}