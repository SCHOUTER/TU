\documentclass[
../../css_summary.tex,
]
{subfiles}

\externaldocument[ext:]{../../css_summary}
% Set Graphics Path, so pictures load correctly
\graphicspath{{../../pics/}}

\begin{document}

\section{Authentifizierung}

\subsection{Grundlagen}

\subsubsection{Begriffsdefinitionen}

\begin{defbox}[Identität]
    Eine Menge von Attributen, die eine Entität beschreiben (z.B. Name, Geburtsdatum, Wohnort).
\end{defbox}

\begin{defbox}[Authentisierung]
    Die \textbf{Bereitstellung} von Unterlagen oder Nachweisen, die es ermöglichen, die Identität zu prüfen (z.B. das Vorzeigen eines Personalausweises).
\end{defbox}

\begin{defbox}[Authentifikation / Authentifizierung]
    Die \textbf{Prüfung} und Echtheitsbezeugung der vorgelegten Unterlagen zur Identitätsfeststellung (z.B. der Vergleich des Fotos auf dem Ausweis mit der Person).
\end{defbox}

\begin{defbox}[Autorisierung]
    Die Gewährung oder Verwehrung von Rechten an eine (authentifizierte) Entität.
\end{defbox}

\subsubsection{Drei Ansätze der Authentisierung}
Ziel ist die Identifikation von Subjekten (Menschen, Systeme, Dienste) und der Nachweis ihrer Identität.

\begin{itemize}
    \item \textbf{Durch Wissen:} z.B. PIN, Passwort, kryptographischer Schlüssel.
    \item \textbf{Durch Besitz:} z.B. Smartcard, Token, SIM-Karte.
    \item \textbf{Durch Merkmale:} z.B. Biometrie (physiologische Eigenschaften).
\end{itemize}

\subsection{Authentisierung durch Besitz}

\begin{itemize}
    \item \textbf{Statische Tokens:} Ein gespeichertes Geheimnis (z.B. privater Schlüssel) wird direkt genutzt.
    \item \textbf{Dynamische Tokens:} Das Geheimnis wird zur Berechnung von Authentifizierungs-Informationen genutzt (z.B. Challenge-Response).
    \item \textbf{Hardware-Tokens:} Schlüssel, SmartCard, Transponder.
    \item \textbf{Software-Tokens:} Cookie, Client-Zertifikat.
\end{itemize}

\subsubsection{Beispiel: ATHENE KARTE (SmartCard)}
\begin{itemize}
    \item Besitzt einen \textbf{Kryptoprozessor} (z.B. CardOS 4.3b).
    \item Träger eines privaten Schlüssels (z.B. 2048 Bit RSA) und eines öffentlichen Zertifikats (digitale ID).
    \item Der \defc{private Schlüssel ist nicht auslesbar} und zusätzlich durch eine PIN geschützt.
\end{itemize}

\subsubsection{Challenge-Response-Verfahren (mit Kryptoprozessor)}
Dies ist ein dynamisches Verfahren, das den privaten Schlüssel nutzt, ohne ihn preiszugeben.
\begin{center}
    \vcentered{\includegraphics[width=0.9\textwidth]{css_1_05_Authentifizierung_page_8_1.png}}
\end{center}

\begin{enumerate}
    \item \textbf{Benutzer (mit Webbrowser)} initiiert eine Zugangsanforderung auf einem Web-Server.
    \item \textbf{Web-Server} generiert eine \textbf{Zufallszahl} (die "Challenge") und sendet sie an den Benutzer.
    \item \textbf{Benutzer} gibt seine PIN ein, um den Kryptoprozessor der Karte freizuschalten. Die Karte "signiert" die Zufallszahl mit dem \textbf{privaten Schlüssel}.
    \item \textbf{Benutzer} sendet die signierte Zufallszahl zurück an den Server.
    \item \textbf{Web-Server} nutzt das \textbf{öffentliche Zertifikat} (Public Key) des Benutzers (das er z.B. bei einer Registrierung erhalten hat), um die Signatur zu prüfen.
    \item Stimmt die verifizierte Zufallszahl mit der ursprünglich gesendeten überein, ist der Benutzer authentifiziert.
\end{enumerate}

\subsubsection{Probleme}
\begin{itemize}
    \item \defc{Diebstahl:} Offensichtliches Problem.
    \item \textbf{Gegenmaßnahme:} Sicherung des Tokens durch ein zusätzliches Merkmal, z.B. Wissen (PIN für Hardware-Crypto, Passwort für Software-Crypto) oder 2. Faktor.
    \item \defc{Extraktion der Schlüssel:} Angriffe auf die Token-Hardware.
    \item \textbf{Methoden:} Schwachstellen in der Firmware oder \textbf{Side-Channel-Angriffe} (z.B. Monitoring des Stromverbrauchs), um den privaten Schlüssel auszulesen.
\end{itemize}

\subsection{Authentisierung durch Merkmale (Biometrie)}

\subsubsection{Anforderungen an biometrische Merkmale}
\begin{itemize}
    \item \textbf{Universalität:} Jede Person besitzt das Merkmal.
    \item \textbf{Eindeutigkeit:} Merkmal ist für jede Person verschieden.
    \item \textbf{Beständigkeit:} Merkmal ist (weitgehend) unveränderlich.
    \item \textbf{Quantitative Erfassbarkeit:} Messbar mittels Sensoren.
    \item \textbf{Performanz:} Genauigkeit und Geschwindigkeit der Erfassung/Prüfung.
    \item \textbf{Akzeptanz:} Benutzer müssen bereit sein, das Merkmal zu nutzen.
    \item \textbf{Fälschungssicherheit:} Schutz gegen Angriffe.
\end{itemize}

\subsubsection{Prozesse und Fehlerraten}
\begin{itemize}
    \item \textbf{Enrollment:} Erstmalige Registrierung eines Benutzers und Erfassung seines Merkmals (Template).
    \item \textbf{Verifikation:} Erneute Erfassung und Vergleich mit dem gespeicherten Template.
    \item \defc{Biometrie ist immer fehlerbehaftet} (ein statistischer Test).
\end{itemize}

\begin{defbox}[Fehlerraten]
    \begin{itemize}
        \item \defc{False Acceptance Rate (FAR):} Ein Unberechtigter wird fälschlicherweise authentifiziert. \textbf{(Sicherheitsproblem!)}
        \item \defc{False Rejection Rate (FRR):} Ein Berechtigter wird fälschlicherweise abgewiesen. \textbf{(Benutzbarkeits-/Akzeptanzproblem!)}
        \item \textbf{Equal Error Rate (EER):} Der Punkt, an dem FAR = FRR.
    \end{itemize}
    Man muss für den Anwendungsfall abwägen: Eine hochsichere Anwendung optimiert auf eine niedrige FAR (auf Kosten der Bequemlichkeit), eine komfortable Anwendung auf eine niedrige FRR.
    \begin{center}
        \vcentered{\includegraphics[width=0.6\textwidth]{css_1_05_Authentifizierung_page_12_1.png}}
    \end{center}
\end{defbox}

\subsubsection{Beispiel: Fingerabdruck}
\begin{itemize}
    \item Es wird nicht das Bild gespeichert, sondern ein Template aus \textbf{Minutien} (Verzweigungen, Endpunkte, etc.) mit relativen Koordinaten und Winkeln.
    \item Problem: Schlechte Abdrücke können zu fehlenden Minutien führen (-> höhere FRR).
\end{itemize}

\subsubsection{Probleme der Biometrie}
\begin{itemize}
    \item \textbf{Datenschutz:} Biometrische Merkmale können "intrusiv" sein und sensible Daten enthüllen (z.B. Venenmuster, DNA -> Gesundheitsdaten).
    \item \textbf{Speicherung:} Es sollten Referenzdaten (Templates) gespeichert werden, aus denen das Merkmal nicht rekonstruiert werden kann.
    \item \defc{Keine oder begrenzte Widerrufbarkeit:} Ein kompromittierter Fingerabdruck (oder Iris, DNA) kann nicht einfach "gesperrt" und ersetzt werden wie ein Passwort.
    \item \textbf{Kompromittierung:} Wenn eine Kopie erstellt werden kann (z.B. von einem Lesegerät gestohlen), wird die Authentifizierung durch \textit{Merkmal} ("Wer bin ich?") zu einer Authentifizierung durch \textit{Wissen} ("Wie sieht Merkmal X aus?").
    \item \textbf{Gegenmaßnahme:} \textbf{Lebendverifikation} (Liveness Detection) prüft, ob ein echter Finger (keine Plastik-Kopie) aufliegt.
\end{itemize}

\subsection{Authentisierung durch Wissen}

\subsubsection{Passwörter}
Gängigste Methode. Werden (idealerweise) nicht im Klartext, sondern als \textbf{Hash-Wert} gespeichert (z.B. in \texttt{/etc/shadow} (Linux) oder via LSASS (Windows)).

\paragraph{Evolution der Passwort-Authentifizierung}
\begin{enumerate}
    \item \textbf{Plaintext-Übertragung:} Passwort wird im Klartext gesendet (z.B. \texttt{telnet}, \texttt{ftp}).
    \item \defc{Problem:} Passiver Angreifer (Sniffer) im Netz sieht alle Passwörter.
    \item \textbf{Übertragung mit TLS:} Der Kanal ist geschützt (z.B. HTTPS).
    \item \defc{Problem:} Wenn der Server das Passwort im Klartext in seiner Datenbank speichert, erlangt ein Angreifer bei einem Datenbank-Leak alle Passwörter.
    \item \textbf{Server speichert Hash:} Server speichert $H_{ID} := h(P_{ID})$. Beim Login sendet der Nutzer $P_{ID}$, der Server berechnet $h(P_{ID})$ und vergleicht es mit dem gespeicherten $H_{ID}$.
    \item \defc{Problem: Rainbow-Tables.} Da $h(\text{"Passwort123"})$ für alle Nutzer gleich ist, kann ein Angreifer eine Tabelle mit Hashes für Millionen gängiger Passwörter vorab berechnen und die gehashte Datenbank sehr schnell knacken.
    \item \textbf{Server speichert Hash mit Salt:} Server speichert $H_{ID} := h(P_{ID}, s_{ID})$, wobei $s_{ID}$ ein einzigartiger, zufälliger \textbf{Salt} pro Nutzer ist (wird mit $H_{ID}$ gespeichert).
    \item \textbf{Vorteil:} $h(\text{"Passwort123"}, s_1) \neq h(\text{"Passwort123"}, s_2)$.
    \item \defc{Eine Rainbow-Table muss nun für jeden Nutzer (jeden Salt) separat erstellt werden}, was den Geschwindigkeitsvorteil zunichte macht und den Angriff stark verlangsamt.
\end{enumerate}

\paragraph{Passwort-Manager}
Da man für unterschiedliche Dienste unterschiedliche, starke Passwörter nutzen soll, ist das Auswendiglernen unmöglich.
\begin{itemize}
    \item \textbf{Lösung:} (Lokale) Passwort-Manager, die mit einem starken Masterpasswort geschützt sind.
\end{itemize}

\subsubsection{Challenge-Response-Verfahren (CHAP)}
Authentisierung durch Wissen, ohne das "Wissen" (Passwort) zu übertragen. Nutzt symmetrische Kryptographie (HMAC).
\begin{itemize}
    \item \textbf{Voraussetzung:} Alice (Nutzer) und Bob (Server) teilen ein Geheimnis ($P_{ID}$, z.B. das Passwort).
    \item \textbf{Ablauf (CHAP):}
          \begin{enumerate}
              \item Alice $\rightarrow$ Bob: $ID$
              \item Bob $\rightarrow$ Alice: $RAND$ (Zufallszahl, "Challenge")
              \item Alice $\rightarrow$ Bob: $c = \text{HMAC}(P_{ID}, RAND)$
              \item Bob prüft: Berechnet $c' = \text{HMAC}(P_{ID}, RAND)$ und testet, ob $c' == c$.
          \end{enumerate}
    \item \textbf{Probleme:}
          \begin{itemize}
              \item Der Klartextraum für $RAND$ muss groß sein, sonst \defc{Replay-Attacke} (Angreifer kann mehrfach genutzte Challenges korrekt beantworten).
              \item Server muss $P_{ID}$ im Klartext kennen. Speichert er stattdessen $h(P_{ID})$, braucht der Angreifer bei einem Leak auch nur noch den Hash (und nicht das Passwort), um sich zu authentifizieren.
              \item Schützt nur die Authentisierung, nicht den restlichen Kommunikationskanal (Integrität).
          \end{itemize}
\end{itemize}

\subsection{Single Sign On (SSO)}

\begin{itemize}
    \item \textbf{Problem:} "Passwort-Müdigkeit" – zu viele Dienste erfordern eigene Passwörter.
    \item \textbf{Definition:} Eine Authentisierungsmethode, die es einem Benutzer ermöglicht, sich mit \textbf{einem einzigen Satz} von Anmeldeinformationen bei \textbf{mehreren unabhängigen} Softwaresystemen anzumelden.
    \item \textbf{Idee:} Ein zentraler, vertrauenswürdiger \textbf{Provider} bestätigt die Identität des Nutzers gegenüber allen anderen \textbf{Services}.
    \item \textbf{Vorteile:} Weniger Passwörter (nur ein starkes nötig), erhöhte Sicherheit (wenn gut implementiert), Komfort, bessere Kontrolle.
    \item \defc{Nachteil: Single Point of Failure.} Wird das SSO-Login kompromittiert, hat ein Angreifer Zugriff auf \textit{alle} verbundenen Dienste.
\end{itemize}

\subsubsection{Kerberos (Ein SSO-Protokoll)}
\begin{itemize}
    \item \textbf{Ziele:} Authentifizierung von \textit{Principals} (Benutzer, Server), Austausch von Sitzungs-Schlüsseln, SSO innerhalb einer administrativen Domäne (\textit{Realm}).
    \item \textbf{Design:}
          \begin{itemize}
              \item Pro \textit{Realm} ein \textbf{Key Distribution Center (KDC)}.
              \item \textbf{KDC} = \textbf{Authentication Server (AS)} + \textbf{Ticket Granting Server (TGS)}.
              \item Basiert auf \textbf{Pre-Shared Secrets}: Das KDC kennt einen geheimen Schlüssel ($K$) für jeden Principal in seinem Realm (z.B. $K_{Bob}$, $K_{TGS}$, $K_{SMB}$). Für Benutzer wird $K_{Bob}$ aus deren Passwort-Hash generiert.
          \end{itemize}
\end{itemize}

\paragraph{Kerberos-Ablauf (vereinfacht)}
Ziel: Benutzer Bob (C) möchte auf den SMB-Server (S) zugreifen.

\begin{enumerate}
    \item \textbf{Login + TGT-Anfrage:}
          \begin{itemize}
              \item Bob gibt sein Passwort ein. Client C generiert $K_{Bob} = \text{Hash}(\text{Passwort})$.
              \item $C \rightarrow AS$: $(K_{Bob}(\text{timestamp}), \text{Bob}, \text{TGS})$ \\ (Bob bittet den AS um ein Ticket für den TGS, authentifiziert sich mit einem verschlüsselten Timestamp).
          \end{itemize}
    \item \textbf{AS-Antwort (TGT):}
          \begin{itemize}
              \item $AS \rightarrow C$: $\{K_{Bob,TGS}\}_{K_{Bob}} + \{TGT\}_{K_{TGS}}$
              \item Der AS prüft den Timestamp. Wenn gültig:
              \item Er sendet den \textbf{Sitzungsschlüssel} für C und TGS ($K_{Bob,TGS}$), verschlüsselt mit Bobs Schlüssel ($K_{Bob}$).
              \item Er sendet das \textbf{Ticket Granting Ticket (TGT)}, welches $(K_{Bob,TGS}, \text{Bob}, ...)$ enthält, alles verschlüsselt mit dem geheimen Schlüssel des TGS ($K_{TGS}$). \defc{Der Client kann das TGT nicht lesen.}
          \end{itemize}
    \item \textbf{Service-Ticket-Anfrage:}
          \begin{itemize}
              \item $C \rightarrow TGS$: $\{A_{Bob}\}_{K_{Bob,TGS}} + \{TGT\}_{K_{TGS}} + \text{"SMB"}$
              \item C entschlüsselt $\{K_{Bob,TGS}\}_{K_{Bob}}$, um den Sitzungsschlüssel $K_{Bob,TGS}$ zu erhalten.
              \item C erstellt einen \textit{Authenticator} $A_{Bob} = (\text{Bob, IP, timestamp})$ und verschlüsselt ihn mit $K_{Bob,TGS}$.
              \item C sendet den Authenticator, das (unlesbare) TGT und den Namen des Zieldienstes ("SMB") an den TGS.
          \end{itemize}
    \item \textbf{TGS-Antwort (Service Ticket):}
          \begin{itemize}
              \item $TGS \rightarrow C$: $\{K_{Bob,SMB}\}_{K_{Bob,TGS}} + \{T_{Bob,SMB}\}_{K_{SMB}}$
              \item TGS entschlüsselt das TGT (mit $K_{TGS}$) und den Authenticator (mit $K_{Bob,TGS}$) und prüft sie.
              \item Er generiert einen neuen Sitzungsschlüssel für Bob und den SMB-Server ($K_{Bob,SMB}$).
              \item Er sendet $K_{Bob,SMB}$, verschlüsselt mit $K_{Bob,TGS}$.
              \item Er sendet das \textbf{Service Ticket} ($T_{Bob,SMB}$), welches $(K_{Bob,SMB}, \text{Bob}, ...)$ enthält, alles verschlüsselt mit dem geheimen Schlüssel des SMB-Servers ($K_{SMB}$).
          \end{itemize}
    \item \textbf{Zugriff auf Dienst:}
          \begin{itemize}
              \item $C \rightarrow SMB$: $\{A_{Bob}'\}_{K_{Bob,SMB}} + \{T_{Bob,SMB}\}_{K_{SMB}}$
              \item C entschlüsselt $K_{Bob,SMB}$.
              \item C erstellt einen *neuen* Authenticator $A_{Bob}'$ und verschlüsselt ihn mit $K_{Bob,SMB}$.
              \item C sendet den neuen Authenticator und das (unlesbare) Service Ticket an den SMB-Server.
          \end{itemize}
    \item \textbf{Verifikation:}
          \begin{itemize}
              \item Der SMB-Server entschlüsselt das Service Ticket (mit $K_{SMB}$) und den Authenticator (mit $K_{Bob,SMB}$) und prüft sie.
              \item Wenn alles gültig ist, ist Bob authentifiziert und Bob und SMB teilen sich den Sitzungsschlüssel $K_{Bob,SMB}$ für die weitere Kommunikation.
          \end{itemize}
\end{enumerate}

\paragraph{Kerberos-Angriffe}
\begin{itemize}
    \item \defc{Pass the Hash:} Der Angreifer stiehlt den Hash $K_{Bob}$ (z.B. aus dem LSASS-Prozessspeicher). Da $K_{Bob}$ das "Geheimnis" ist, das Kerberos verwendet, kann der Angreifer \textbf{Schritt 1} des Protokolls direkt ausführen und ein TGT erhalten, \textbf{ohne das Klartextpasswort zu kennen.}
    \item \defc{Golden Ticket:} Der Angreifer kompromittiert das KDC und stiehlt den geheimen Schlüssel des TGS selbst (den Hash des \texttt{KRBTGT}-Kontos). Mit diesem Schlüssel kann der Angreifer \textbf{offline} ein TGT für \textbf{jeden beliebigen Benutzer} (z.B. Administrator) mit \textbf{beliebiger Gültigkeitsdauer} fälschen. Dies gewährt dem Angreifer uneingeschränkten, persistenten Zugriff auf die gesamte Domäne.
\end{itemize}

\subsection{Autorisierung (Zugriffskontrollmodelle)}
Nach der Authentifizierung (Wer bist du?) folgt die Autorisierung (Was darfst du?).
\begin{itemize}
    \item \textbf{Referenzmonitor:} Ein abstraktes Konzept, das jede Anfrage eines \textbf{Subjekts} (Prozess, Benutzer) auf ein \textbf{Objekt} (Datei, Speicher) prüft und anhand einer Rechtedatenbank entscheidet (gewährt / abgelehnt).
    \item \textbf{Schutzziele:} Integrität und Vertraulichkeit.
\end{itemize}

\subsubsection{Discretionary Access Control (DAC)}
\begin{center}
    \vcentered{\includegraphics[width=0.9\textwidth]{css_1_05_Authentifizierung_page_49_1.png}}
\end{center}
\begin{itemize}
    \item \textbf{Definition:} Der \textbf{Eigentümer} eines Objekts ist für die Vergabe von Zugriffsrechten verantwortlich ("at his discretion").
    \item \textbf{Modell:} \textbf{Zugriffsmatrix} ($M: S \times O \rightarrow \mathcal{P}(R)$), die Rechte von Subjekten $S$ auf Objekte $O$ abbildet.
    \item \textbf{Implementierung (Speicherung der Matrix):}
          \begin{itemize}
              \item \textbf{Spaltenweise (Access Control Lists, ACLs):} Jedes \textit{Objekt} hat eine Liste, die alle Subjekte und deren Rechte aufführt. (z.B. Dateiberechtigungen in Windows/Linux).
              \item \textit{Vorteil:} Effizient zu bestimmen: "Wer darf auf diese Datei zugreifen?"
              \item \textbf{Zeilenweise (Capability Lists, CLs):} Jedes \textit{Subjekt} hat eine Liste (Capability) mit allen Objekten, auf die es zugreifen darf, und den jeweiligen Rechten.
              \item \textit{Vorteil:} Effizient zu bestimmen: "Worauf darf dieser Benutzer zugreifen?"
          \end{itemize}
    \item \textbf{Nachteile:} Keine formalen Garantien für Informationsfluss (Problem "Trojanisches Pferd": Ein Programm, das im Kontext des Nutzers läuft, kann dessen Rechte missbrauchen, z.B. eine Datei kopieren und unerlaubt weitergeben).
\end{itemize}

\subsubsection{Role-based Access Control (RBAC)}
\begin{itemize}
    \item \textbf{Definition:} Berechtigungen werden nicht direkt an Benutzer, sondern an \textbf{Rollen} (z.B. "Arzt", "Buchhalter", "Admin") vergeben. Benutzer werden dann diesen Rollen zugewiesen.
    \item \textbf{Vorteile:} Bildet Organisationsstrukturen gut ab; erleichtert Prinzipien wie "Need-to-Know" und "Separation-of-Duty".
\end{itemize}

\subsubsection{Mandatory Access Control (MAC)}
\begin{itemize}
    \item \textbf{Definition:} Systembestimmte (regelbasierte) Festlegung von Sicherheitseigenschaften. \textbf{Systemregeln dominieren (überschreiben) Benutzerwünsche} (DAC-Einstellungen).
    \item \textbf{Ziel:} Kontrolle des Informationsflusses.
\end{itemize}

\paragraph{Beispiel: Bell-La Padula (BLP) Modell}
Ein MAC-Modell, das sich auf \textbf{Vertraulichkeit} (Confidentiality) konzentriert.
\begin{itemize}
    \item \textbf{Konzept:} Subjekte und Objekte erhalten \textbf{Sicherheitsklassen (Labels)}, z.B. (Level, \{Kategorien\}).
    \item \textbf{Level:} Haben eine totale Ordnung (z.B. unklassifiziert $<$ vertraulich $<$ geheim $<$ streng geheim).
    \item \textbf{Kategorien:} Eine Menge von Zuständigkeiten (z.B. \{Buchhaltung\}, \{Forschung\}).
    \item \textbf{Dominanz ($\ge$):} Ein Subjekt $S$ dominiert ein Objekt $O$ ($SC(S) \ge SC(O)$), wenn $S$ ein höheres oder gleiches Level hat \textbf{und} die Kategoriemenge von $O$ eine Teilmenge der Kategoriemenge von $S$ ist ($L_S \ge L_O \wedge C_O \subseteq C_S$).
\end{itemize}

\begin{defbox}[Bell-La Padula Regeln]
    \begin{itemize}
        \item \textbf{1. Simple-Security-Property (No-Read-Up):}
        \item Ein Subjekt $S$ darf ein Objekt $O$ nur \textbf{lesen}, wenn $SC(S) \ge SC(O)$ (Subjekt dominiert Objekt).
        \item \textit{(Ein "geheimer" Sekretär darf keine "streng geheimen" Bilanzdaten lesen).}
        \item \textbf{2. $\ast$-Property (No-Write-Down):}
        \item Ein Subjekt $S$ darf ein Objekt $O$ nur \textbf{schreiben}, wenn $SC(S) \le SC(O)$ (Objekt dominiert Subjekt).
        \item \textit{(Ein "strenger geheimer" CEO darf Bilanzdaten nicht in eine "unlassifizierte" Website schreiben und so leaken).}
    \end{itemize}
\end{defbox}

\begin{itemize}
    \item \textbf{Nachteile BLP:} Informationen fließen sukzessive nur "nach oben". Erlaubt "blindes Schreiben" (Schreiben in ein Objekt, das man nicht mehr lesen darf $\rightarrow$ Integritätsproblem). Modelliert keine "Covert Channels".
\end{itemize}

\end{document}