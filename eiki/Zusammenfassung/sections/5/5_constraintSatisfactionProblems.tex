\documentclass[../../eiki_summary.tex]{subfiles}

\externaldocument[ext:]{../../eiki_summary}
% Set Graphics Path, so pictures load correctly

\begin{document}

\section{Constraint Satisfaction Problems (CSPs)}Constraint Satisfaction Problems (CSPs) stellen einen Paradigmenwechsel gegenüber der klassischen Pfadsuche dar. Während bei Planungsproblemen der Pfad zum Ziel entscheidend ist, interessiert bei CSPs nur der Zielzustand selbst (Identifikationsproblem). Der Zustand ist dabei nicht mehr atomar (``Blackbox''), sondern faktorisiert, d. h. er besteht aus Variablen und Werten.

\subsection{Definition und Komponenten}Ein CSP wird durch drei Komponenten definiert:
\begin{enumerate}
  \item \textbf{Variablen} $X = \{X_1, X_2, ..., X_n\}$: Die Objekte, denen Werte zugewiesen werden müssen.
  \item \textbf{Domänen} (Wertebereiche) $D = \{D_1, D_2, ..., D_n\}$: Für jede Variable $X_i$ gibt es eine Menge $D_i$ von möglichen Werten.
  \item \textbf{Constraints} (Beschränkungen) $C$: Eine Menge von Regeln, die spezifizieren, welche Kombinationen von Werten für Teilmengen der Variablen zulässig sind.\end{enumerate}\begin{defbox}[Zustandszuweisungen]\begin{itemize}
    \item \textbf{Partielle Zuweisung:} Nur einigen Variablen wurden Werte zugewiesen (z. B. $X_1 = v_1$).
    \item \textbf{Konsistente (legale) Zuweisung:} Eine Zuweisung, die keinen Constraint verletzt.
    \item \textbf{Vollständige Zuweisung:} Jeder Variablen ist ein Wert zugewiesen.
    \item \textbf{Lösung:} Eine vollständige und konsistente Zuweisung.
  \end{itemize}
\end{defbox}

\begin{center}
  \vcentered{\includegraphics[width=0.7\textwidth]{eiki_1_AI101-05_page_22_2.png}}
\end{center}
Knoten = Variablen (Regionen), Kanten = Constraints (benachbart)

\subsection{Arten von Constraints}Constraints schränken die möglichen Belegungen der Variablen ein:

\begin{itemize}
  \item \textbf{Unäre Constraints:} Betreffen eine einzelne Variable (z. B. $SA \neq \text{green}$).
  \item \textbf{Binäre Constraints:} Betreffen Paare von Variablen (z. B. $SA \neq WA$). Dies ist die häufigste Form und kann durch einen \defc{Constraint-Graphen} dargestellt werden.
  \item \textbf{Constraints höherer Ordnung:} Betreffen 3 oder mehr Variablen (z. B. bei Kryptogrammen wie $TWO + TWO = FOUR$).
  \item \textbf{Soft Constraints (Präferenzen):} Dienen der Optimierung (z. B. ``Rot ist besser als Grün''). Diese wandeln das CSP oft in ein \textit{Constrained Optimization Problem} um.
\end{itemize}

\subsection{Lösungsansätze: Suche und Backtracking}
Da die Reihenfolge der Zuweisungen bei CSPs keine Rolle spielt (Kommutativität), muss nicht der gesamte Zustandsraum als Baum mit $n! \cdot v^n$ Blättern durchsucht werden. Es reicht aus, pro Ebene eine Variable zu betrachten. Dies reduziert den Suchraum auf $v^n$ Blätter.

\subsubsection{Backtracking Search}
Backtracking ist eine Tiefensuche (Depth-First Search), die für CSPs optimiert
ist.
\begin{itemize}
  \item Wähle eine unzugewiesene Variable.
  \item Probiere nacheinander alle Werte aus der Domäne.
  \item Wenn ein Wert konsistent ist: Weise ihn zu und rekursiere.
  \item Wenn ein Wert inkonsistent ist oder die Rekursion fehlschlägt: Mache die
        Zuweisung rückgängig (Backtrack) und versuche den nächsten Wert.
\end{itemize}

Ohne Heuristiken entspricht dies einer uninformierten Suche. Um die Effizienz zu steigern (z. B. Lösung des $n$-Damen-Problems für $n>25$), werden Heuristiken für die Auswahl von Variablen und Werten sowie Inferenzmethoden (Propagation) benötigt.\subsection{Heuristiken für Backtracking}Um die Suche zu beschleunigen, müssen an jedem Entscheidungspunkt drei Fragen beantwortet werden:

\subsubsection{1. Welche Variable soll als nächste belegt werden?}
Hier gilt das Prinzip: \textit{Fail-first} (Scheitere so früh wie möglich, um große Teile des Suchbaums abzuschneiden).
\begin{defbox}[Variablen-Auswahl]
  \begin{itemize}
    \item \defc{Minimum Remaining Values (MRV):} Wähle die Variable mit den \textit{wenigsten} verbleibenden legalen Werten. Dies führt am schnellsten zu einem Fehler, wenn ein Zweig keine Lösung enthält.
    \item \defc{Degree Heuristic:} (Wird oft als Tie-Breaker für MRV genutzt). Wähle die Variable, die an den \textit{meisten} Constraints mit anderen \textit{noch nicht zugewiesenen} Variablen beteiligt ist.
  \end{itemize}
\end{defbox}

\subsubsection{2. Welchen Wert soll die Variable annehmen?}
Hier gilt das Prinzip: \textit{Fail-last} (Lasse möglichst viele Optionen für die Zukunft offen).

\begin{defbox}[Werte-Auswahl]
  \defc{Least Constraining Value (LCV):} Wähle den Wert, der die \textit{wenigsten} Werte in den Domänen der benachbarten Variablen ausschließt. Dies erhöht die Chance, direkt eine Lösung zu finden.
\end{defbox}

\subsection{Constraint Propagation (Inferenz)}
Anstatt nur zu suchen und bei Konflikten zurückzugehen, kann man durch Inferenz den Suchraum proaktiv verkleinern, indem man Werte ausschließt, die unmöglich Teil einer Lösung sein können.

\subsubsection{Konsistenzarten}
\begin{itemize}
  \item \textbf{Node Consistency (Knotenkonsistenz):} Jede Variable erfüllt ihre unären Constraints.
  \item \textbf{Arc Consistency (Kantenkonsistenz):} Eine Variable $X$ ist kantenkonsistent zu einer Variable $Y$, wenn für \textit{jeden} Wert $x \in D_X$ mindestens ein Wert $y \in D_Y$ existiert, der den binären Constraint zwischen $X$ und $Y$ erfüllt.
  \item \textbf{Path Consistency / k-Consistency:} Verallgemeinerung auf Tripel oder $k$ Variablen. Stärkere Konsistenz prüft mehr, ist aber rechenaufwendiger.\end{itemize}
\begin{center}
  \vcentered{\includegraphics[width=0.7\textwidth]{eiki_1_AI101-05_page_37_1.png}}
\end{center}

\subsubsection{Forward Checking vs. Arc Consistency}
\begin{itemize}
  \item \textbf{Forward Checking:} Sobald $X$ ein Wert zugewiesen wird, werden alle inkonsistenten Werte aus den Domänen der direkten Nachbarn entfernt. Wenn eine Domäne leer wird, backtrackt der Algorithmus.\textit{Nachteil:} Erkennt Konflikte nicht früh genug (sieht z. B. nicht, dass zwei zukünftige Variablen inkonsistent zueinander geworden sind).
  \item \textbf{Arc Consistency (AC-3 Algorithmus):} Propagiert Constraints durch das gesamte Netzwerk. Wenn aus $D_X$ ein Wert entfernt wird, müssen alle Nachbarn von $X$ erneut geprüft werden, da deren Unterstützung verloren gegangen sein könnte.\end{itemize}\begin{defbox}[AC-3 Algorithmus Kernidee]Verwende eine Warteschlange (Queue) aller Kanten (Arcs).Solange die Queue nicht leer ist:\begin{enumerate}
    \item Entnimm Kante $(X_i, X_j)$.
    \item Entferne alle Werte aus $D_i$, die keinen Partner in $D_j$ haben.
    \item Wenn Werte aus $D_i$ entfernt wurden: Füge alle Kanten $(X_k, X_i)$ (Nachbarn, die von $X_i$ abhängen) wieder zur Queue hinzu.
  \end{enumerate}
\end{defbox}
Die Kombination aus Backtracking und AC-3 wird als \defc{MAC} (Maintaining Arc Consistency) bezeichnet.

\subsection{Lokale Suche für CSPs}Für Probleme, bei denen der Pfad egal ist, kann auch Lokale Suche (Hill Climbing, Simulated Annealing) auf \textit{vollständigen} (aber inkonsistenten) Zuweisungen arbeiten.

\textbf{Min-Conflicts Heuristik:}
\begin{itemize}
  \item Wähle zufällig eine Variable, die einen Constraint verletzt.
  \item Wähle für diese Variable den Wert, der die \textit{Anzahl der verletzten Constraints} minimiert.
\end{itemize}

Diese Methode ist erstaunlich effizient (z. B. Million-Queens in Minuten), außer in einem kritischen Bereich des Verhältnisses von Constraints zu Variablen (\textit{Critical Ratio}).

\subsection{Struktur von CSPs}
Die Struktur des Constraint-Graphen beeinflusst die Komplexität der Lösung massiv.

\subsubsection{Problem-Dekomposition}
Wenn ein Graph in unabhängige Teilgraphen zerfällt, kann die Komplexität von $O(d^n)$ auf $O(n/c \cdot d^c)$ reduziert werden (lineare Skalierung in $n$)

\subsubsection{Baumstrukturierte CSPs}
Wenn der Constraint-Graph ein Baum ist (keine Zyklen), kann das CSP in linearer Zeit $O(n \cdot d^2)$ gelöst werden.
\textbf{Algorithmus für Bäume:}
\textit{Topologische Sortierung:} Ordne Variablen so, dass jeder Knoten nach seinem Elternknoten kommt (Wurzel bis Blätter).
\textit{Rückwärts-Pass (Konsistenz):} Mache von den Blättern zur Wurzel hin alle Kanten gerichtete kantenkonsistent (entferne Werte im Elternknoten, die keine Entsprechung im Kind haben).
\textit{Vorwärts-Pass (Zuweisung):} Weise von der Wurzel zu den Blättern Werte zu. Da die Konsistenz hergestellt wurde, gibt es kein Backtracking.

\subsubsection{Fast-Baum-Strukturen (Cutset Conditioning)}
Für Graphen, die ``fast'' Bäume sind:

\begin{enumerate}
  \item Identifiziere ein \defc{Cycle Cutset} (Menge von Variablen, deren Entfernung den Graphen zum Baum macht).
  \item Instantiiere die Variablen im Cutset (probiere alle Kombinationen).
  \item Löse den verbleibenden Baum für jede Instantiierung (``Residual CSP'').
  \item Die Laufzeit ist exponentiell nur in der Größe des Cutsets, nicht in $n$.
\end{enumerate}

\begin{center}
  \vcentered{\includegraphics[width=0.7\textwidth]{eiki_1_AI101-05_page_53_1.png}}
\end{center}

\end{document}