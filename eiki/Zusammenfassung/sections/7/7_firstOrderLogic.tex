\documentclass[../../eiki_summary.tex]{subfiles}

\externaldocument[ext:]{../../eiki_summary}
% Set Graphics Path, so pictures load correctly

\begin{document}

\section{Logic and AI 2: First-Order Logic (FOL)}

\subsection{Einführung und Motivation}
Die Aussagenlogik (Propositional Logic) hat erhebliche Einschränkungen. Sie behandelt Fakten atomar und besitzt kein Verständnis für Objekte und deren Beziehungen untereinander.
\begin{itemize}
  \item In der Aussagenlogik haben Terme keine formale Bedeutung, nur eine intuitive (z. B. ist ``RoommateCarryingUmbrella'' technisch gesehen nur eine Variable $P$).
  \item \defc{Prädikatenlogik erster Stufe} (First-Order Logic, FOL) führt Objekte, Variablen und Quantoren ein, um Wissen kompakter und strukturierter darzustellen.
\end{itemize}

% Hier könnte das Bild aus Slide 5 (Roommate Story) eingefügt werden, um das Szenario zu illustrieren.

\subsection{Syntax und Elemente der FOL}
Die FOL baut auf folgenden Grundbausteinen auf:

\begin{defbox}[Elemente der FOL]
  \begin{itemize}
    \item \textbf{Objekte:} Konstanten, die spezifische Entitäten bezeichnen (z. B. $John, Umbrella_0, Earth$).
    \item \textbf{Relationen (Prädikate):} Beziehungen zwischen Objekten.
          \begin{itemize}
            \item \textit{Unäre Relationen}: Eigenschaften eines Objekts (z. B. $IsUmbrella(x)$).
            \item \textit{n-äre Relationen}: Beziehungen zwischen $n$ Objekten (z. B. $Carrying(John, Umbrella_0)$).
          \end{itemize}
    \item \textbf{Funktionen:} Abbildungen, die sich auf Objekte beziehen, ohne sie explizit zu benennen (z. B. $Roommate(Person_0)$ oder $LeftLegOf(John)$). Wichtig: Eine Funktion liefert ein Objekt zurück, keinen Wahrheitswert.
    \item \textbf{Gleichheit:} $Term_1 = Term_2$ (z. B. $Roommate(Person_0) = Person_1$).
  \end{itemize}
\end{defbox}

\subsubsection{Quantoren}
Um Aussagen über Mengen von Objekten zu treffen, werden Variablen ($x, y, z$) und Quantoren verwendet:

1. \defc{Allquantor} ($\forall$): ``Für alle\ldots''\
\begin{itemize}
  \item Beispiel: Alle Löwen sind Katzen.
  \item $\forall x: Lion(x) \implies Cat(x)$
  \item \textit{Hinweis:} Der Allquantor wird meistens mit der Implikation ($\implies$) verwendet.
\end{itemize}

2. \defc{Existenzquantor} ($\exists$): ``Es existiert (mindestens) ein\ldots''\
\begin{itemize}
  \item Beispiel: Es gibt eine Katze, die kein Löwe ist.
  \item $\exists x: Cat(x) \land \neg Lion(x)$
  \item \textit{Hinweis:} Der Existenzquantor wird meistens mit der Konjunktion ($\land$) verwendet.
\end{itemize}

\textbf{Dualität der Quantoren:}
Die Quantoren lassen sich ineinander umformen:
\[ \forall x: P(x) \equiv \neg \exists x: \neg P(x) \]
\[ \exists x: P(x) \equiv \neg \forall x: \neg P(x) \]

\subsection{Modellierung: Von natürlicher Sprache zu FOL}
Das Übersetzen von Sätzen erfordert präzise Muster. Hier einige wichtige Beispiele und Strukturen (auch basierend auf Übungsaufgaben):

\begin{itemize}
  \item \textbf{Einfache Eigenschaft:} ``John hat einen Regenschirm''
        $\exists y: (Has(John, y) \land IsUmbrella(y))$

  \item \textbf{Verschachtelung:} ``Jede Person, die einen Schirm hat, ist nicht nass''
        $\forall x: (Person(x) \implies ((\exists y: Has(x, y) \land Umbrella(y)) \implies \neg Wet(x)))$

  \item \textbf{Mindestens zwei (Distinctness):} ``John hat mindestens zwei Schirme''
        $\exists x, y: (Has(John, x) \land Umbrella(x) \land Has(John, y) \land Umbrella(y) \land \neg(x=y))$

  \item \textbf{Höchstens zwei:} ``John hat höchstens zwei Schirme''
        $\forall x, y, z: ((Has(John, x) \ldots \land Has(John, z) \ldots) \implies (x=y \lor x=z \lor y=z))$

  \item \textbf{Genau ein (Uniqueness):} ``Es liegt genau eine Münze in der Kiste''
        $\exists x (Coin(x) \land InBox(x) \land \forall y ((Coin(y) \land InBox(y)) \implies x=y))$
\end{itemize}

\subsection{Inferenz in FOL}

\subsubsection{Substitution (SUBST)}
Um logische Schlüsse zu ziehen, müssen Variablen oft durch konkrete Terme ersetzt werden.
\begin{itemize}
  \item Syntax: $SUBST(\{x/John\}, IsHealthy(x)) \rightarrow IsHealthy(John)$
  \item \textbf{Universal Instantiation:} Aus $\forall x: \alpha$ kann $SUBST(\{x/g\}, \alpha)$ für jeden Grundterm $g$ abgeleitet werden.
  \item \textbf{Existential Instantiation:} Aus $\exists x: \alpha$ kann $SUBST(\{x/k\}, \alpha)$ abgeleitet werden, wobei $k$ eine \defc{neue} Konstante ist (Skolem-Konstante), die noch nicht in der Wissensbasis vorkommt.
\end{itemize}

\subsubsection{Skolemierung}
Die Eliminierung von Existenzquantoren ist ein zentraler Schritt für Resolutionsbeweise. Dabei ist die Position des Quantors entscheidend:

\begin{defbox}[Skolemierung Regeln]
  \begin{enumerate}
    \item \textbf{Existenzquantor steht allein (oder ganz außen):}
          Ersetze die Variable durch eine neue Konstante (Skolem-Konstante).
          \[ \exists x: P(x) \rightarrow P(A) \]

    \item \textbf{Existenzquantor steht im Wirkungsbereich eines Allquantors:}
          Die existierende Variable hängt von der allquantifizierten Variable ab. Ersetze $y$ durch eine \defc{Skolem-Funktion} $f(x)$.
          \[ \forall x \exists y: IsParentOf(x, y) \rightarrow \forall x: IsParentOf(x, f(x)) \]
          Hierbei bildet $f(x)$ das passende $y$ für jedes $x$ ab.
  \end{enumerate}
\end{defbox}

% Hier könnte das Bild von Albert Thoralf Skolem (Slide 16) als Referenz stehen.

\subsubsection{Unifikation}
Ein Algorithmus, der eine Substitution $\theta$ findet, sodass zwei Ausdrücke identisch werden. Dies ist die Grundlage für den verallgemeinerten Modus Ponens und die Resolution.
Beispiel:
\begin{itemize}
  \item Term 1: $Knows(John, x)$
  \item Term 2: $Knows(y, Jane)$
  \item Unifikator $\theta = \{x/Jane, y/John\}$ resultiert in $Knows(John, Jane)$.
\end{itemize}

\subsection{Resolution in FOL}
Wie in der Aussagenlogik ist die Resolution eine Widerlegungsmethode (Beweis durch Widerspruch). Um sie anzuwenden, müssen Sätze in die \defc{Konjunktive Normalform (CNF)} gebracht werden.

\begin{defbox}[Umwandlung in First-Order CNF]
  \begin{enumerate}
    \item \textbf{Implikationen eliminieren:} $A \implies B$ wird zu $\neg A \lor B$.
    \item \textbf{Negationen nach innen ziehen:} (De Morgan Regeln), sodass $\neg$ nur direkt vor Atomen steht.
    \item \textbf{Variablen standardisieren:} Umbenennen, sodass jeder Quantor eindeutige Variablennamen verwendet.
    \item \textbf{Skolemierung:} Eliminierung aller Existenzquantoren (durch Konstanten oder Funktionen).
    \item \textbf{Allquantoren verwerfen:} Da nun alle Variablen allquantifiziert sind, können die $\forall$ weggelassen werden (implizite Annahme).
    \item \textbf{Verteilung (Distributivgesetz):} Umwandlung in Konjunktion von Disjunktionen (UND von ODERs).
    \item \textbf{Klauselbildung:} Darstellung als Menge von Klauseln.
  \end{enumerate}
\end{defbox}

\textbf{Beispielablauf:}
Satz: ``Jeder, der nicht getötet wird und isst, ist Nahrung''
\[ \forall x \forall y: (Eats(x,y) \land \neg Killed(x)) \implies Food(y) \]
$\rightarrow$ Implikation weg: $\neg (Eats(x,y) \land \neg Killed(x)) \lor Food(y)$
$\rightarrow$ De Morgan: $\neg Eats(x,y) \lor Killed(x) \lor Food(y)$
Dies ist bereits eine Klausel.

\subsection{Prolog (Programming in Logic)}
Prolog ist eine Programmiersprache, die auf FOL (speziell Horn-Klauseln) basiert und Unifikation sowie Backtracking-Suche verwendet.

\begin{itemize}
  \item \textbf{Fakten:} `eats(sam, dal).` (Entspricht $Eats(Sam, Dal)$).
  \item \textbf{Regeln:} `head :- body.` (Bedeutet: Head ist wahr, \textit{wenn} Body wahr ist. Logisch: $Body \implies Head$).
  \item \textbf{Syntax:}
        \begin{itemize}
          \item \textit{Großbuchstaben} sind Variablen (z. B. `Person', `X`).
          \item \textit{Kleinbuchstaben} sind Atome/Konstanten (z. B. \texttt{sam}, \texttt{curry}).
          \item \texttt{\_} ist eine anonyme Variable.
          \item Komma \texttt{,} bedeutet UND (Konjunktion).
        \end{itemize}
  \item \textbf{Inferenz:} Prolog nutzt Tiefensuche (Depth-First Search) mit Backtracking. Wenn eine Unifikation fehlschlägt, geht das System zurück und probiert die nächste Alternative.
\end{itemize}

% Hier Bild zur Prolog-Tabelle oder Baumstruktur (Slide 23/29) einfügen.

\subsection{Grenzen der Prädikatenlogik}

\begin{itemize}
  \item \textbf{Entscheidbarkeit:} FOL ist \defc{semi-entscheidbar}.
        \begin{itemize}
          \item Wenn ein Satz aus der Wissensbasis folgt, existiert ein Algorithmus, der dies beweist (er terminiert).
          \item Wenn ein Satz \textit{nicht} folgt, terminiert der Algorithmus möglicherweise nie.
        \end{itemize}
  \item \textbf{Ausdrucksstärke:} Man kann nicht über Relationen selbst quantifizieren (z. B. ``Für alle Eigenschaften $p$\ldots''). Dies würde Logik höherer Stufe (Higher-Order Logic) erfordern.
  \item \textbf{Gödels Unvollständigkeitssatz:} In jedem formalen System, das mächtig genug ist, um Arithmetik (Induktion) abzubilden, gibt es wahre Aussagen, die innerhalb des Systems nicht beweisbar sind. Vollständigkeit in komplexen Systemen ist unmöglich.
\end{itemize}

\subsection{Neuro-Symbolic AI (Ausblick)}
Moderne Ansätze versuchen, die logische Schlussfolgerung (Symbole, Prolog) mit neuronalen Netzen (Wahrnehmung, Lernen) zu kombinieren.
\begin{itemize}
  \item Ziel: Ein System, das sowohl aus Daten lernt (Gradient Descent) als auch logische Regeln befolgt.
  \item Beispiel: Ein Agent, der Pixeldaten wahrnimmt (Neural), aber Entscheidungen auf Basis logischer Regeln (z. B. ``Wenn Gegner nah, dann springen'') trifft oder diese Regeln lernt.
\end{itemize}

\end{document}